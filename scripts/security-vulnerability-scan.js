#!/usr/bin/env node

/**
 * å…¨ç«™å®‰å…¨æ¼æ´ä¸€é”®æ£€æµ‹è„šæœ¬
 * æ”¯æŒæ¨¡æ‹Ÿæ”¯ä»˜å’ŒçœŸå®æ”¯ä»˜ä¸¤ç§æµ‹è¯•åœºæ™¯
 *
 * æ£€æµ‹å†…å®¹ï¼š
 * 1. SQLæ³¨å…¥æ”»å‡»
 * 2. XSSè·¨ç«™è„šæœ¬æ”»å‡»
 * 3. CSRFè·¨ç«™è¯·æ±‚ä¼ªé€ 
 * 4. æƒé™ç»•è¿‡ä¸è¶Šæƒè®¿é—®
 * 5. ä»·æ ¼ç¯¡æ”¹æ”»å‡»
 * 6. URL/è·¯å¾„æ³¨å…¥
 * 7. è®¤è¯ç»•è¿‡
 * 8. æ•æ„Ÿä¿¡æ¯æ³„éœ²
 * 9. è¾“å…¥éªŒè¯æ¼æ´
 * 10. ä¼šè¯å®‰å…¨
 * 11. æ”¯ä»˜æµç¨‹å®‰å…¨
 * 12. è®¢å•é€»è¾‘æ¼æ´
 *
 * ä½¿ç”¨æ–¹æ³•ï¼š
 * node scripts/security-vulnerability-scan.js [mock|real]
 *
 * ç¤ºä¾‹ï¼š
 * node scripts/security-vulnerability-scan.js mock   # ä½¿ç”¨æ¨¡æ‹Ÿæ”¯ä»˜æµ‹è¯•
 * node scripts/security-vulnerability-scan.js real   # ä½¿ç”¨çœŸå®æ”¯ä»˜æµ‹è¯•ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
 */

const https = require('https');
const http = require('http');

// é…ç½®
const config = {
  baseUrl: process.env.TEST_BASE_URL || 'http://localhost:3000',
  paymentMode: process.argv[2] || 'mock',
  timeout: 30000,
  testUser: {
    email: `security-test-${Date.now()}@example.com`,
    password: 'Test123456!@#',
    name: 'å®‰å…¨æµ‹è¯•ç”¨æˆ·'
  }
};

// åˆ›å»ºæ”¯æŒè‡ªç­¾åè¯ä¹¦çš„ agent
const agent = config.baseUrl.startsWith('https')
  ? new https.Agent({ rejectUnauthorized: false })
  : new http.Agent();

// æµ‹è¯•ç»“æœç»Ÿè®¡
const scanResults = {
  total: 0,
  passed: 0,
  failed: 0,
  critical: 0,
  high: 0,
  medium: 0,
  low: 0,
  vulnerabilities: []
};

// ä¼šè¯ç®¡ç†
let userSession = null;
let adminSession = null;

// é¢œè‰²è¾“å‡º
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`âœ“ ${message}`, 'green');
}

function logVulnerability(severity, message) {
  const severityColors = {
    critical: 'red',
    high: 'red',
    medium: 'yellow',
    low: 'cyan'
  };
  const icon = severity === 'critical' || severity === 'high' ? 'ğŸš¨' : 'âš ï¸';
  log(`${icon} [${severity.toUpperCase()}] ${message}`, severityColors[severity]);
}

function logInfo(message) {
  log(`â„¹ ${message}`, 'cyan');
}

function logSection(message) {
  log(`\n${'='.repeat(80)}`, 'blue');
  log(`  ${message}`, 'bright');
  log('='.repeat(80), 'blue');
}

// HTTP è¯·æ±‚å°è£…
async function request(path, options = {}) {
  const url = `${config.baseUrl}${path}`;
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), config.timeout);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
      agent
    });
    clearTimeout(timeoutId);

    const contentType = response.headers.get('content-type');
    let data;

    try {
      if (contentType && contentType.includes('application/json')) {
        data = await response.json();
      } else {
        data = await response.text();
      }
    } catch (e) {
      data = null;
    }

    return { response, data };
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}

// æµ‹è¯•è®°å½•
function recordTest(testName, passed, severity = 'medium', details = '') {
  scanResults.total++;

  if (passed) {
    scanResults.passed++;
  } else {
    scanResults.failed++;
    scanResults[severity]++;
    scanResults.vulnerabilities.push({
      name: testName,
      severity,
      details
    });
  }

  return passed;
}

function getHeaders(includeAuth = false, session = null) {
  const headers = {
    'Content-Type': 'application/json'
  };

  if (includeAuth) {
    const cookieToUse = session || userSession;
    if (cookieToUse) {
      headers['Cookie'] = cookieToUse;
    }
  }

  return headers;
}

// ==================== å®‰å…¨æµ‹è¯•ç”¨ä¾‹ ====================

// 1. SQLæ³¨å…¥æ”»å‡»æ£€æµ‹
async function testSQLInjection() {
  logSection('1. SQLæ³¨å…¥æ”»å‡»æ£€æµ‹');

  const sqlPayloads = [
    "' OR '1'='1",
    "1' OR '1' = '1",
    "' OR 1=1--",
    "admin'--",
    "' UNION SELECT NULL--",
    "1; DROP TABLE users--",
    "1' AND '1'='1",
  ];

  for (const payload of sqlPayloads) {
    try {
      // æµ‹è¯•äº§å“æœç´¢
      const { response, data } = await request(`/api/products?search=${encodeURIComponent(payload)}`);

      const isSafe = response.status !== 500 &&
                     (!data || typeof data === 'object') &&
                     !JSON.stringify(data).includes('SQL') &&
                     !JSON.stringify(data).includes('syntax error');

      if (!isSafe) {
        recordTest(
          `SQLæ³¨å…¥é˜²æŠ¤ - æœç´¢å‚æ•°: ${payload}`,
          false,
          'critical',
          'SQLæ³¨å…¥æ”»å‡»å¯èƒ½æˆåŠŸï¼Œæ£€æµ‹åˆ°æ•°æ®åº“é”™è¯¯ä¿¡æ¯æ³„éœ²'
        );
        logVulnerability('critical', `SQLæ³¨å…¥æ¼æ´: æœç´¢å‚æ•° "${payload}"`);
      } else {
        recordTest(`SQLæ³¨å…¥é˜²æŠ¤ - ${payload.substring(0, 20)}...`, true);
        logSuccess(`SQLæ³¨å…¥å·²æ‹¦æˆª: ${payload.substring(0, 30)}...`);
      }
    } catch (error) {
      recordTest(`SQLæ³¨å…¥æµ‹è¯• - ${payload}`, true);
      logSuccess(`SQLæ³¨å…¥å·²æ‹¦æˆªï¼ˆè¯·æ±‚å¼‚å¸¸ï¼‰`);
    }
  }
}

// 2. XSSè·¨ç«™è„šæœ¬æ”»å‡»æ£€æµ‹
async function testXSSAttacks() {
  logSection('2. XSSè·¨ç«™è„šæœ¬æ”»å‡»æ£€æµ‹');

  const xssPayloads = [
    '<script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    '<svg/onload=alert("XSS")>',
    'javascript:alert("XSS")',
    '<iframe src="javascript:alert(\'XSS\')">',
    '"><script>alert(String.fromCharCode(88,83,83))</script>',
    '<body onload=alert("XSS")>',
  ];

  for (const payload of xssPayloads) {
    try {
      // æµ‹è¯•åˆ›å»ºç”¨æˆ·æ—¶çš„XSS
      const { response, data } = await request('/api/auth/register', {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify({
          email: `xss-test-${Date.now()}@example.com`,
          password: 'Test123456',
          name: payload
        })
      });

      // æ£€æŸ¥å“åº”ä¸­æ˜¯å¦åŒ…å«æœªè½¬ä¹‰çš„è„šæœ¬
      const responseText = JSON.stringify(data);
      const hasXSS = responseText.includes('<script>') ||
                     responseText.includes('onerror=') ||
                     responseText.includes('onload=') ||
                     responseText.includes('javascript:');

      if (hasXSS) {
        recordTest(
          `XSSé˜²æŠ¤ - ${payload.substring(0, 30)}`,
          false,
          'high',
          'XSSæ”»å‡»è½½è·æœªè¢«æ­£ç¡®è½¬ä¹‰æˆ–è¿‡æ»¤'
        );
        logVulnerability('high', `XSSæ¼æ´: è½½è·æœªè½¬ä¹‰ "${payload.substring(0, 30)}..."`);
      } else {
        recordTest(`XSSé˜²æŠ¤ - ${payload.substring(0, 30)}...`, true);
        logSuccess(`XSSå·²æ‹¦æˆª: ${payload.substring(0, 30)}...`);
      }
    } catch (error) {
      recordTest(`XSSæµ‹è¯• - ${payload}`, true);
      logSuccess(`XSSå·²æ‹¦æˆªï¼ˆè¯·æ±‚å¤±è´¥ï¼‰`);
    }
  }
}

// 3. CSRFè·¨ç«™è¯·æ±‚ä¼ªé€ æ£€æµ‹
async function testCSRFProtection() {
  logSection('3. CSRFè·¨ç«™è¯·æ±‚ä¼ªé€ æ£€æµ‹');

  try {
    // ç™»å½•è·å–ä¼šè¯
    const { response: loginRes } = await request('/api/auth/register', {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify(config.testUser)
    });

    if (loginRes.headers.get('set-cookie')) {
      userSession = loginRes.headers.get('set-cookie').split(';')[0];
    }

    // æµ‹è¯•æ— CSRF Tokençš„æ•æ„Ÿæ“ä½œ
    const { response } = await request('/api/cart', {
      method: 'POST',
      headers: getHeaders(true),
      body: JSON.stringify({
        productId: 'test-product',
        quantity: 1
      })
    });

    // å¦‚æœæ²¡æœ‰CSRFä¿æŠ¤ï¼Œè¿™ä¸ªè¯·æ±‚åº”è¯¥æˆåŠŸ
    // ç†æƒ³æƒ…å†µä¸‹åº”è¯¥è¦æ±‚CSRF token
    const hasCSRFProtection = response.headers.get('x-csrf-token') !== null;

    recordTest(
      'CSRFä¿æŠ¤æ£€æµ‹',
      hasCSRFProtection,
      hasCSRFProtection ? 'low' : 'medium',
      hasCSRFProtection ? 'CSRFä¿æŠ¤å·²å¯ç”¨' : 'æœªæ£€æµ‹åˆ°CSRF Tokenä¿æŠ¤'
    );

    if (hasCSRFProtection) {
      logSuccess('CSRFä¿æŠ¤å·²å¯ç”¨');
    } else {
      logVulnerability('medium', 'CSRFä¿æŠ¤: æœªæ£€æµ‹åˆ°CSRF Tokenæœºåˆ¶');
    }

  } catch (error) {
    logInfo(`CSRFæµ‹è¯•: ${error.message}`);
  }
}

// 4. æƒé™ç»•è¿‡ä¸è¶Šæƒè®¿é—®æ£€æµ‹
async function testAuthorizationBypass() {
  logSection('4. æƒé™ç»•è¿‡ä¸è¶Šæƒè®¿é—®æ£€æµ‹');

  const adminEndpoints = [
    { path: '/api/backendmanager/products', method: 'GET', name: 'å•†å“ç®¡ç†' },
    { path: '/api/backendmanager/users', method: 'GET', name: 'ç”¨æˆ·ç®¡ç†' },
    { path: '/api/backendmanager/orders', method: 'GET', name: 'è®¢å•ç®¡ç†' },
    { path: '/api/backendmanager/security-alerts', method: 'GET', name: 'å®‰å…¨è­¦æŠ¥' },
    { path: '/api/backendmanager/system-config', method: 'GET', name: 'ç³»ç»Ÿé…ç½®' },
  ];

  for (const endpoint of adminEndpoints) {
    try {
      // æµ‹è¯•1: å®Œå…¨æœªç™»å½•è®¿é—®
      const { response: unauthRes } = await request(endpoint.path, {
        method: endpoint.method
      });

      const blocksUnauth = unauthRes.status === 401 || unauthRes.status === 403;
      recordTest(
        `æœªæˆæƒè®¿é—®æ‹¦æˆª - ${endpoint.name}`,
        blocksUnauth,
        blocksUnauth ? 'low' : 'critical',
        blocksUnauth ? 'æœªæˆæƒè®¿é—®å·²æ‹¦æˆª' : 'æœªæˆæƒè®¿é—®æˆåŠŸï¼ä¸¥é‡å®‰å…¨æ¼æ´'
      );

      if (!blocksUnauth) {
        logVulnerability('critical', `æƒé™ç»•è¿‡: æœªç™»å½•å¯è®¿é—® ${endpoint.path}`);
      } else {
        logSuccess(`æœªæˆæƒè®¿é—®å·²æ‹¦æˆª: ${endpoint.name}`);
      }

      // æµ‹è¯•2: æ™®é€šç”¨æˆ·è®¿é—®ç®¡ç†ç«¯ç‚¹
      if (userSession) {
        const { response: userRes } = await request(endpoint.path, {
          method: endpoint.method,
          headers: getHeaders(true, userSession)
        });

        const blocksUser = userRes.status === 401 || userRes.status === 403;
        recordTest(
          `æ™®é€šç”¨æˆ·è¶Šæƒè®¿é—®æ‹¦æˆª - ${endpoint.name}`,
          blocksUser,
          blocksUser ? 'low' : 'critical',
          blocksUser ? 'è¶Šæƒè®¿é—®å·²æ‹¦æˆª' : 'æ™®é€šç”¨æˆ·å¯è®¿é—®ç®¡ç†åŠŸèƒ½ï¼'
        );

        if (!blocksUser) {
          logVulnerability('critical', `è¶Šæƒè®¿é—®: æ™®é€šç”¨æˆ·å¯è®¿é—® ${endpoint.path}`);
        } else {
          logSuccess(`è¶Šæƒè®¿é—®å·²æ‹¦æˆª: ${endpoint.name}`);
        }
      }

    } catch (error) {
      logInfo(`æƒé™æµ‹è¯•å¼‚å¸¸: ${endpoint.name} - ${error.message}`);
    }
  }
}

// 5. ä»·æ ¼ç¯¡æ”¹æ”»å‡»æ£€æµ‹
async function testPriceManipulation() {
  logSection('5. ä»·æ ¼ç¯¡æ”¹æ”»å‡»æ£€æµ‹');

  try {
    // è·å–ä¸€ä¸ªçœŸå®å•†å“
    const { data: productsData } = await request('/api/products');

    if (!productsData.products || productsData.products.length === 0) {
      logInfo('æ²¡æœ‰å•†å“å¯æµ‹è¯•ï¼Œè·³è¿‡ä»·æ ¼ç¯¡æ”¹æµ‹è¯•');
      return;
    }

    const product = productsData.products[0];
    const realPrice = product.price;

    // å°è¯•ç¯¡æ”¹ä»·æ ¼åˆ›å»ºè®¢å•
    const tamperedPrices = [
      0.01,              // æä½ä»·æ ¼
      -100,              // è´Ÿæ•°ä»·æ ¼
      realPrice * 0.001  // ç¯¡æ”¹åˆ°æä½æŠ˜æ‰£
    ];

    for (const tamperedPrice of tamperedPrices) {
      try {
        const { response, data } = await request('/api/orders', {
          method: 'POST',
          headers: getHeaders(true),
          body: JSON.stringify({
            items: [{
              productId: product.id,
              quantity: 1,
              price: tamperedPrice  // å°è¯•ç¯¡æ”¹ä»·æ ¼
            }],
            totalAmount: tamperedPrice,
            paymentMethod: 'alipay'
          })
        });

        // æ£€æŸ¥æ˜¯å¦æ¥å—äº†ç¯¡æ”¹çš„ä»·æ ¼
        const acceptedTamperedPrice = response.ok &&
          data.order &&
          data.order.totalAmount < realPrice * 0.5;

        recordTest(
          `ä»·æ ¼ç¯¡æ”¹é˜²æŠ¤ - ${tamperedPrice}å…ƒ`,
          !acceptedTamperedPrice,
          acceptedTamperedPrice ? 'critical' : 'low',
          acceptedTamperedPrice
            ? `æ¥å—äº†ç¯¡æ”¹ä»·æ ¼ ${tamperedPrice}å…ƒï¼ˆåŸä»·${realPrice}å…ƒï¼‰`
            : 'ä»·æ ¼ç¯¡æ”¹å·²æ‹¦æˆª'
        );

        if (acceptedTamperedPrice) {
          logVulnerability('critical', `ä»·æ ¼ç¯¡æ”¹æˆåŠŸ: ${realPrice}å…ƒ -> ${tamperedPrice}å…ƒ`);
        } else {
          logSuccess(`ä»·æ ¼ç¯¡æ”¹å·²æ‹¦æˆª: å°è¯•å°†${realPrice}å…ƒæ”¹ä¸º${tamperedPrice}å…ƒ`);
        }

      } catch (error) {
        recordTest(`ä»·æ ¼ç¯¡æ”¹æµ‹è¯• - ${tamperedPrice}`, true);
        logSuccess(`ä»·æ ¼ç¯¡æ”¹å·²æ‹¦æˆªï¼ˆè¯·æ±‚å¤±è´¥ï¼‰`);
      }
    }

  } catch (error) {
    logInfo(`ä»·æ ¼ç¯¡æ”¹æµ‹è¯•: ${error.message}`);
  }
}

// 6. URL/è·¯å¾„æ³¨å…¥æ£€æµ‹
async function testPathInjection() {
  logSection('6. URL/è·¯å¾„æ³¨å…¥æ£€æµ‹');

  const pathPayloads = [
    '../../../etc/passwd',
    '..\\..\\..\\windows\\system32',
    'file:///etc/passwd',
    'javascript:alert(1)',
    'data:text/html,<script>alert(1)</script>',
  ];

  for (const payload of pathPayloads) {
    try {
      const { response, data } = await request(`/api/products/${encodeURIComponent(payload)}`);

      // æ£€æŸ¥æ˜¯å¦æ³„éœ²äº†ç³»ç»Ÿæ–‡ä»¶æˆ–æ‰§è¡Œäº†æ¶æ„ä»£ç 
      const responseText = typeof data === 'string' ? data : JSON.stringify(data);
      const hasPathTraversal = responseText.includes('root:') ||
                               responseText.includes('bin/bash') ||
                               responseText.includes('[System Process]');

      recordTest(
        `è·¯å¾„æ³¨å…¥é˜²æŠ¤ - ${payload.substring(0, 30)}`,
        !hasPathTraversal,
        hasPathTraversal ? 'critical' : 'low',
        hasPathTraversal ? 'è·¯å¾„éå†æˆåŠŸï¼Œç³»ç»Ÿæ–‡ä»¶æ³„éœ²' : 'è·¯å¾„æ³¨å…¥å·²æ‹¦æˆª'
      );

      if (hasPathTraversal) {
        logVulnerability('critical', `è·¯å¾„éå†æ¼æ´: ${payload}`);
      } else {
        logSuccess(`è·¯å¾„æ³¨å…¥å·²æ‹¦æˆª: ${payload.substring(0, 30)}...`);
      }

    } catch (error) {
      recordTest(`è·¯å¾„æ³¨å…¥æµ‹è¯• - ${payload}`, true);
      logSuccess(`è·¯å¾„æ³¨å…¥å·²æ‹¦æˆªï¼ˆè¯·æ±‚å¤±è´¥ï¼‰`);
    }
  }
}

// 7. è®¤è¯ç»•è¿‡æ£€æµ‹
async function testAuthenticationBypass() {
  logSection('7. è®¤è¯ç»•è¿‡æ£€æµ‹');

  const protectedEndpoints = [
    { path: '/api/orders', method: 'GET', name: 'è®¢å•åˆ—è¡¨' },
    { path: '/api/cart', method: 'GET', name: 'è´­ç‰©è½¦' },
    { path: '/api/memberships/verify', method: 'GET', name: 'ä¼šå‘˜éªŒè¯' },
  ];

  for (const endpoint of protectedEndpoints) {
    try {
      const { response } = await request(endpoint.path, {
        method: endpoint.method
      });

      const requiresAuth = response.status === 401 || response.status === 403;

      recordTest(
        `è®¤è¯è¦æ±‚ - ${endpoint.name}`,
        requiresAuth,
        requiresAuth ? 'low' : 'high',
        requiresAuth ? 'éœ€è¦è®¤è¯' : 'æ— éœ€è®¤è¯å³å¯è®¿é—®'
      );

      if (!requiresAuth && response.ok) {
        logVulnerability('high', `è®¤è¯ç»•è¿‡: ${endpoint.path} æ— éœ€ç™»å½•å³å¯è®¿é—®`);
      } else {
        logSuccess(`è®¤è¯ä¿æŠ¤æ­£å¸¸: ${endpoint.name}`);
      }

    } catch (error) {
      logInfo(`è®¤è¯æµ‹è¯•å¼‚å¸¸: ${endpoint.name}`);
    }
  }
}

// 8. æ•æ„Ÿä¿¡æ¯æ³„éœ²æ£€æµ‹
async function testInformationDisclosure() {
  logSection('8. æ•æ„Ÿä¿¡æ¯æ³„éœ²æ£€æµ‹');

  try {
    // æµ‹è¯•é”™è¯¯ä¿¡æ¯æ³„éœ²
    const { response, data } = await request('/api/products/non-existent-id-12345');

    const responseText = JSON.stringify(data);
    const leaksSensitiveInfo =
      responseText.includes('prisma') ||
      responseText.includes('database') ||
      responseText.includes('stack trace') ||
      responseText.includes('at Object.') ||
      responseText.match(/\/home\/.*\//) ||
      responseText.match(/C:\\.*\\/);

    recordTest(
      'æ•æ„Ÿä¿¡æ¯æ³„éœ²é˜²æŠ¤',
      !leaksSensitiveInfo,
      leaksSensitiveInfo ? 'medium' : 'low',
      leaksSensitiveInfo ? 'é”™è¯¯ä¿¡æ¯æ³„éœ²äº†ç³»ç»Ÿè·¯å¾„æˆ–æ•°æ®åº“ä¿¡æ¯' : 'æ— æ•æ„Ÿä¿¡æ¯æ³„éœ²'
    );

    if (leaksSensitiveInfo) {
      logVulnerability('medium', 'æ•æ„Ÿä¿¡æ¯æ³„éœ²: é”™è¯¯æ¶ˆæ¯åŒ…å«ç³»ç»Ÿå†…éƒ¨ä¿¡æ¯');
    } else {
      logSuccess('æ•æ„Ÿä¿¡æ¯ä¿æŠ¤æ­£å¸¸');
    }

    // æµ‹è¯•ç”¨æˆ·ä¿¡æ¯æ³„éœ²
    const { data: usersData } = await request('/api/backendmanager/users');

    if (usersData && Array.isArray(usersData.users)) {
      const hasPasswordField = usersData.users.some(user =>
        user.password !== undefined && user.password !== null
      );

      recordTest(
        'ç”¨æˆ·å¯†ç ä¿¡æ¯ä¿æŠ¤',
        !hasPasswordField,
        hasPasswordField ? 'critical' : 'low',
        hasPasswordField ? 'APIè¿”å›äº†ç”¨æˆ·å¯†ç ä¿¡æ¯' : 'å¯†ç ä¿¡æ¯å·²è¿‡æ»¤'
      );

      if (hasPasswordField) {
        logVulnerability('critical', 'ç”¨æˆ·å¯†ç æ³„éœ²: APIè¿”å›äº†å¯†ç å­—æ®µ');
      } else {
        logSuccess('ç”¨æˆ·å¯†ç ä¿¡æ¯å·²è¿‡æ»¤');
      }
    }

  } catch (error) {
    logInfo(`ä¿¡æ¯æ³„éœ²æµ‹è¯•: ${error.message}`);
  }
}

// 9. è¾“å…¥éªŒè¯æ¼æ´æ£€æµ‹
async function testInputValidation() {
  logSection('9. è¾“å…¥éªŒè¯æ¼æ´æ£€æµ‹');

  const invalidInputs = [
    { name: 'è¶…é•¿é‚®ç®±', email: 'a'.repeat(1000) + '@example.com', severity: 'medium' },
    { name: 'ç©ºé‚®ç®±', email: '', severity: 'low' },
    { name: 'æ— æ•ˆé‚®ç®±æ ¼å¼', email: 'not-an-email', severity: 'low' },
    { name: 'è¶…é•¿å¯†ç ', password: 'a'.repeat(10000), severity: 'medium' },
    { name: 'ç‰¹æ®Šå­—ç¬¦å¯†ç ', password: '\x00\x01\x02\x03', severity: 'low' },
  ];

  for (const input of invalidInputs) {
    try {
      const { response } = await request('/api/auth/register', {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify({
          email: input.email || `test-${Date.now()}@example.com`,
          password: input.password || 'Test123456',
          name: 'Test User'
        })
      });

      const rejectsInvalidInput = response.status === 400 || response.status === 422;

      recordTest(
        `è¾“å…¥éªŒè¯ - ${input.name}`,
        rejectsInvalidInput,
        rejectsInvalidInput ? 'low' : input.severity,
        rejectsInvalidInput ? 'æ— æ•ˆè¾“å…¥å·²æ‹’ç»' : 'æ¥å—äº†æ— æ•ˆè¾“å…¥'
      );

      if (!rejectsInvalidInput && response.ok) {
        logVulnerability(input.severity, `è¾“å…¥éªŒè¯ç¼ºå¤±: ${input.name}`);
      } else {
        logSuccess(`è¾“å…¥éªŒè¯æ­£å¸¸: ${input.name}`);
      }

    } catch (error) {
      recordTest(`è¾“å…¥éªŒè¯æµ‹è¯• - ${input.name}`, true);
      logSuccess(`è¾“å…¥éªŒè¯æ­£å¸¸: ${input.name}ï¼ˆè¯·æ±‚å¤±è´¥ï¼‰`);
    }
  }
}

// 10. ä¼šè¯å®‰å…¨æ£€æµ‹
async function testSessionSecurity() {
  logSection('10. ä¼šè¯å®‰å…¨æ£€æµ‹');

  try {
    // ç™»å½•å¹¶è·å–ä¼šè¯
    const { response: loginRes } = await request('/api/auth/register', {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({
        ...config.testUser,
        email: `session-test-${Date.now()}@example.com`
      })
    });

    const setCookie = loginRes.headers.get('set-cookie');

    if (setCookie) {
      const hasHttpOnly = setCookie.includes('HttpOnly');
      const hasSecure = setCookie.includes('Secure') || !config.baseUrl.startsWith('https');
      const hasSameSite = setCookie.includes('SameSite');

      recordTest(
        'ä¼šè¯Cookie - HttpOnlyæ ‡å¿—',
        hasHttpOnly,
        hasHttpOnly ? 'low' : 'medium',
        hasHttpOnly ? 'HttpOnlyå·²å¯ç”¨' : 'Cookieç¼ºå°‘HttpOnlyæ ‡å¿—'
      );

      recordTest(
        'ä¼šè¯Cookie - Secureæ ‡å¿—',
        hasSecure,
        hasSecure ? 'low' : 'medium',
        hasSecure ? 'Secureæ ‡å¿—æ­£å¸¸' : 'Cookieç¼ºå°‘Secureæ ‡å¿—ï¼ˆHTTPSç¯å¢ƒï¼‰'
      );

      recordTest(
        'ä¼šè¯Cookie - SameSiteä¿æŠ¤',
        hasSameSite,
        hasSameSite ? 'low' : 'medium',
        hasSameSite ? 'SameSiteå·²å¯ç”¨' : 'Cookieç¼ºå°‘SameSiteä¿æŠ¤'
      );

      if (!hasHttpOnly) {
        logVulnerability('medium', 'ä¼šè¯Cookieç¼ºå°‘HttpOnlyæ ‡å¿—ï¼Œæ˜“å—XSSæ”»å‡»');
      }
      if (!hasSecure && config.baseUrl.startsWith('https')) {
        logVulnerability('medium', 'ä¼šè¯Cookieç¼ºå°‘Secureæ ‡å¿—');
      }
      if (!hasSameSite) {
        logVulnerability('medium', 'ä¼šè¯Cookieç¼ºå°‘SameSiteä¿æŠ¤ï¼Œæ˜“å—CSRFæ”»å‡»');
      }

      if (hasHttpOnly && hasSecure && hasSameSite) {
        logSuccess('ä¼šè¯Cookieå®‰å…¨é…ç½®å®Œå–„');
      }
    } else {
      logInfo('æœªæ£€æµ‹åˆ°ä¼šè¯Cookie');
    }

  } catch (error) {
    logInfo(`ä¼šè¯å®‰å…¨æµ‹è¯•: ${error.message}`);
  }
}

// 11. æ”¯ä»˜æµç¨‹å®‰å…¨æ£€æµ‹
async function testPaymentSecurity() {
  logSection(`11. æ”¯ä»˜æµç¨‹å®‰å…¨æ£€æµ‹ (${config.paymentMode}æ¨¡å¼)`);

  try {
    // è·å–å•†å“
    const { data: productsData } = await request('/api/products');

    if (!productsData.products || productsData.products.length === 0) {
      logInfo('æ²¡æœ‰å•†å“å¯æµ‹è¯•æ”¯ä»˜æµç¨‹');
      return;
    }

    const product = productsData.products[0];

    // åˆ›å»ºè®¢å•
    const { response: orderRes, data: orderData } = await request('/api/orders', {
      method: 'POST',
      headers: getHeaders(true),
      body: JSON.stringify({
        items: [{
          productId: product.id,
          quantity: 1,
          price: product.price
        }],
        totalAmount: product.price,
        paymentMethod: 'alipay'
      })
    });

    if (!orderRes.ok || !orderData.order) {
      logInfo('è®¢å•åˆ›å»ºå¤±è´¥ï¼Œè·³è¿‡æ”¯ä»˜æµ‹è¯•');
      return;
    }

    const order = orderData.order;

    if (config.paymentMode === 'mock') {
      // æµ‹è¯•æ”¯ä»˜å›è°ƒéªŒè¯
      logInfo('æµ‹è¯•æ”¯ä»˜å›è°ƒå®‰å…¨...');

      // æµ‹è¯•1: ä¼ªé€ æ”¯ä»˜æˆåŠŸå›è°ƒ
      const { response: callbackRes1 } = await request('/api/payment/callback', {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify({
          orderNumber: order.orderNumber,
          status: 'success',
          // ç¼ºå°‘ç­¾åæˆ–éªŒè¯ä¿¡æ¯
        })
      });

      const rejectsUnsignedCallback = callbackRes1.status === 400 || callbackRes1.status === 403;

      recordTest(
        'æ”¯ä»˜å›è°ƒç­¾åéªŒè¯',
        rejectsUnsignedCallback,
        rejectsUnsignedCallback ? 'low' : 'critical',
        rejectsUnsignedCallback ? 'æ‹’ç»æœªç­¾åå›è°ƒ' : 'æ¥å—æœªéªŒè¯çš„æ”¯ä»˜å›è°ƒï¼'
      );

      if (!rejectsUnsignedCallback) {
        logVulnerability('critical', 'æ”¯ä»˜å›è°ƒæ— ç­¾åéªŒè¯ï¼Œå¯ä¼ªé€ æ”¯ä»˜æˆåŠŸ');
      } else {
        logSuccess('æ”¯ä»˜å›è°ƒéªŒè¯æ­£å¸¸');
      }

      // æµ‹è¯•2: é‡å¤æ”¯ä»˜å›è°ƒ
      const { response: paymentRes } = await request('/api/payment/create', {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify({
          orderId: order.id,
          orderNumber: order.orderNumber,
          amount: order.totalAmount,
          paymentMethod: 'alipay'
        })
      });

      if (paymentRes.ok) {
        const paymentData = await paymentRes.json();

        // æ¨¡æ‹Ÿæ”¯ä»˜å›è°ƒ
        await request('/api/payment/callback', {
          method: 'POST',
          headers: getHeaders(),
          body: JSON.stringify({
            paymentId: paymentData.paymentId,
            orderNumber: order.orderNumber,
            status: 'success'
          })
        });

        // å°è¯•é‡å¤å›è°ƒ
        const { response: duplicateRes } = await request('/api/payment/callback', {
          method: 'POST',
          headers: getHeaders(),
          body: JSON.stringify({
            paymentId: paymentData.paymentId,
            orderNumber: order.orderNumber,
            status: 'success'
          })
        });

        const preventsDuplicateCallback = duplicateRes.status === 400 || duplicateRes.status === 409;

        recordTest(
          'é‡å¤æ”¯ä»˜å›è°ƒé˜²æŠ¤',
          preventsDuplicateCallback,
          preventsDuplicateCallback ? 'low' : 'high',
          preventsDuplicateCallback ? 'é‡å¤å›è°ƒå·²æ‹¦æˆª' : 'å¯é‡å¤å¤„ç†æ”¯ä»˜å›è°ƒ'
        );

        if (!preventsDuplicateCallback) {
          logVulnerability('high', 'æ”¯ä»˜å›è°ƒå¯é‡å¤å¤„ç†ï¼Œå¯èƒ½å¯¼è‡´é‡å¤å‘è´§');
        } else {
          logSuccess('é‡å¤æ”¯ä»˜å›è°ƒé˜²æŠ¤æ­£å¸¸');
        }
      }

    } else {
      logInfo('çœŸå®æ”¯ä»˜æ¨¡å¼ï¼šè·³è¿‡è‡ªåŠ¨åŒ–æ”¯ä»˜å®‰å…¨æµ‹è¯•');
      logInfo('è¯·æ‰‹åŠ¨æµ‹è¯•ï¼š');
      logInfo('  1. æ”¯ä»˜é‡‘é¢æ˜¯å¦å¯ç¯¡æ”¹');
      logInfo('  2. æ”¯ä»˜å›è°ƒæ˜¯å¦æœ‰ç­¾åéªŒè¯');
      logInfo('  3. æ˜¯å¦é˜²æ­¢é‡å¤æ”¯ä»˜');
    }

  } catch (error) {
    logInfo(`æ”¯ä»˜å®‰å…¨æµ‹è¯•: ${error.message}`);
  }
}

// 12. è®¢å•é€»è¾‘æ¼æ´æ£€æµ‹
async function testOrderLogicVulnerabilities() {
  logSection('12. è®¢å•é€»è¾‘æ¼æ´æ£€æµ‹');

  try {
    // è·å–å•†å“
    const { data: productsData } = await request('/api/products');

    if (!productsData.products || productsData.products.length === 0) {
      logInfo('æ²¡æœ‰å•†å“å¯æµ‹è¯•è®¢å•é€»è¾‘');
      return;
    }

    const product = productsData.products[0];

    // æµ‹è¯•1: è´Ÿæ•°æ•°é‡
    const { response: negativeQtyRes } = await request('/api/orders', {
      method: 'POST',
      headers: getHeaders(true),
      body: JSON.stringify({
        items: [{
          productId: product.id,
          quantity: -10,
          price: product.price
        }],
        totalAmount: product.price * -10,
        paymentMethod: 'alipay'
      })
    });

    const rejectsNegativeQty = negativeQtyRes.status === 400 || negativeQtyRes.status === 422;

    recordTest(
      'è®¢å•æ•°é‡éªŒè¯ - è´Ÿæ•°',
      rejectsNegativeQty,
      rejectsNegativeQty ? 'low' : 'high',
      rejectsNegativeQty ? 'è´Ÿæ•°æ•°é‡å·²æ‹’ç»' : 'æ¥å—è´Ÿæ•°æ•°é‡è®¢å•'
    );

    if (!rejectsNegativeQty) {
      logVulnerability('high', 'è®¢å•é€»è¾‘æ¼æ´: æ¥å—è´Ÿæ•°æ•°é‡');
    } else {
      logSuccess('è´Ÿæ•°æ•°é‡éªŒè¯æ­£å¸¸');
    }

    // æµ‹è¯•2: è¶…å¤§æ•°é‡
    const { response: largeQtyRes } = await request('/api/orders', {
      method: 'POST',
      headers: getHeaders(true),
      body: JSON.stringify({
        items: [{
          productId: product.id,
          quantity: 999999999,
          price: product.price
        }],
        totalAmount: product.price * 999999999,
        paymentMethod: 'alipay'
      })
    });

    const rejectsLargeQty = largeQtyRes.status === 400 || largeQtyRes.status === 422;

    recordTest(
      'è®¢å•æ•°é‡éªŒè¯ - è¶…å¤§æ•°é‡',
      rejectsLargeQty,
      rejectsLargeQty ? 'low' : 'medium',
      rejectsLargeQty ? 'è¶…å¤§æ•°é‡å·²æ‹’ç»' : 'æ¥å—è¶…å¤§æ•°é‡è®¢å•ï¼ˆå¯èƒ½å¯¼è‡´æº¢å‡ºï¼‰'
    );

    if (!rejectsLargeQty) {
      logVulnerability('medium', 'è®¢å•é€»è¾‘æ¼æ´: æ¥å—è¶…å¤§æ•°é‡ï¼Œå¯èƒ½å¯¼è‡´æ•´æ•°æº¢å‡º');
    } else {
      logSuccess('è¶…å¤§æ•°é‡éªŒè¯æ­£å¸¸');
    }

    // æµ‹è¯•3: é‡‘é¢ä¸åŒ¹é…
    const { response: mismatchRes } = await request('/api/orders', {
      method: 'POST',
      headers: getHeaders(true),
      body: JSON.stringify({
        items: [{
          productId: product.id,
          quantity: 1,
          price: product.price
        }],
        totalAmount: 0.01, // æ•…æ„ä¸åŒ¹é…çš„æ€»é‡‘é¢
        paymentMethod: 'alipay'
      })
    });

    const rejectsMismatch = mismatchRes.status === 400 || mismatchRes.status === 422;

    recordTest(
      'è®¢å•é‡‘é¢éªŒè¯ - é‡‘é¢ä¸åŒ¹é…',
      rejectsMismatch,
      rejectsMismatch ? 'low' : 'critical',
      rejectsMismatch ? 'é‡‘é¢ä¸åŒ¹é…å·²æ‹¦æˆª' : 'æ¥å—ä¸åŒ¹é…çš„è®¢å•é‡‘é¢'
    );

    if (!rejectsMismatch) {
      logVulnerability('critical', 'è®¢å•é€»è¾‘æ¼æ´: æ¥å—ä¸åŒ¹é…çš„è®¢å•é‡‘é¢');
    } else {
      logSuccess('è®¢å•é‡‘é¢éªŒè¯æ­£å¸¸');
    }

  } catch (error) {
    logInfo(`è®¢å•é€»è¾‘æµ‹è¯•: ${error.message}`);
  }
}

// 13. æ–‡ä»¶ä¸Šä¼ å®‰å…¨æ£€æµ‹
async function testFileUploadSecurity() {
  logSection('13. æ–‡ä»¶ä¸Šä¼ å®‰å…¨æ£€æµ‹');

  try {
    // æµ‹è¯•æ¶æ„æ–‡ä»¶ä¸Šä¼ 
    const maliciousFiles = [
      { name: 'shell.php', type: 'application/x-php', content: '<?php system($_GET["cmd"]); ?>' },
      { name: 'test.svg', type: 'image/svg+xml', content: '<svg><script>alert(1)</script></svg>' },
      { name: '../../../etc/passwd.jpg', type: 'image/jpeg', content: 'fake-image' },
    ];

    for (const file of maliciousFiles) {
      try {
        const formData = new FormData();
        const blob = new Blob([file.content], { type: file.type });
        formData.append('file', blob, file.name);

        const { response } = await request('/api/upload/image', {
          method: 'POST',
          headers: {
            ...(userSession ? { 'Cookie': userSession } : {})
          },
          body: formData
        });

        const rejectsMaliciousFile = response.status === 400 || response.status === 403 || response.status === 422;

        recordTest(
          `æ–‡ä»¶ä¸Šä¼ éªŒè¯ - ${file.name}`,
          rejectsMaliciousFile,
          rejectsMaliciousFile ? 'low' : 'high',
          rejectsMaliciousFile ? 'æ¶æ„æ–‡ä»¶å·²æ‹’ç»' : 'æ¥å—äº†æ¶æ„æ–‡ä»¶'
        );

        if (!rejectsMaliciousFile && response.ok) {
          logVulnerability('high', `æ–‡ä»¶ä¸Šä¼ æ¼æ´: æ¥å—äº†æ¶æ„æ–‡ä»¶ ${file.name}`);
        } else {
          logSuccess(`æ–‡ä»¶ä¸Šä¼ éªŒè¯æ­£å¸¸: ${file.name}`);
        }

      } catch (error) {
        recordTest(`æ–‡ä»¶ä¸Šä¼ æµ‹è¯• - ${file.name}`, true);
        logSuccess(`æ–‡ä»¶ä¸Šä¼ éªŒè¯æ­£å¸¸: ${file.name}ï¼ˆè¯·æ±‚å¤±è´¥ï¼‰`);
      }
    }

  } catch (error) {
    logInfo(`æ–‡ä»¶ä¸Šä¼ æµ‹è¯•: ${error.message}`);
  }
}

// 14. APIé€Ÿç‡é™åˆ¶æ£€æµ‹
async function testRateLimiting() {
  logSection('14. APIé€Ÿç‡é™åˆ¶æ£€æµ‹');

  try {
    logInfo('æµ‹è¯•APIé€Ÿç‡é™åˆ¶ï¼ˆå‘é€20ä¸ªå¿«é€Ÿè¯·æ±‚ï¼‰...');

    const requests = [];
    for (let i = 0; i < 20; i++) {
      requests.push(request('/api/products'));
    }

    const responses = await Promise.all(requests);
    const rateLimited = responses.some(r => r.response.status === 429);

    recordTest(
      'APIé€Ÿç‡é™åˆ¶',
      rateLimited,
      rateLimited ? 'low' : 'medium',
      rateLimited ? 'APIé€Ÿç‡é™åˆ¶å·²å¯ç”¨' : 'æœªæ£€æµ‹åˆ°é€Ÿç‡é™åˆ¶ï¼ˆå¯èƒ½æ˜“å—DDoSæ”»å‡»ï¼‰'
    );

    if (rateLimited) {
      logSuccess('APIé€Ÿç‡é™åˆ¶å·²å¯ç”¨');
    } else {
      logVulnerability('medium', 'APIé€Ÿç‡é™åˆ¶: æœªæ£€æµ‹åˆ°é€Ÿç‡é™åˆ¶ä¿æŠ¤');
    }

  } catch (error) {
    logInfo(`é€Ÿç‡é™åˆ¶æµ‹è¯•: ${error.message}`);
  }
}

// ==================== ä¸»æµ‹è¯•æµç¨‹ ====================

async function runSecurityScan() {
  log('\n' + '='.repeat(80), 'magenta');
  log('  ğŸ”’ å®‰å…¨æ¼æ´æ‰«æå¼€å§‹', 'bright');
  log('='.repeat(80), 'magenta');
  log(`  ç›®æ ‡ URL: ${config.baseUrl}`, 'cyan');
  log(`  æ”¯ä»˜æ¨¡å¼: ${config.paymentMode === 'mock' ? 'æ¨¡æ‹Ÿæ”¯ä»˜' : 'çœŸå®æ”¯ä»˜'}`, 'cyan');
  log(`  æ‰«ææ—¶é—´: ${new Date().toLocaleString('zh-CN')}`, 'cyan');
  log('='.repeat(80) + '\n', 'magenta');

  const startTime = Date.now();

  try {
    await testSQLInjection();
    await testXSSAttacks();
    await testCSRFProtection();
    await testAuthorizationBypass();
    await testPriceManipulation();
    await testPathInjection();
    await testAuthenticationBypass();
    await testInformationDisclosure();
    await testInputValidation();
    await testSessionSecurity();
    await testPaymentSecurity();
    await testOrderLogicVulnerabilities();
    await testFileUploadSecurity();
    await testRateLimiting();

  } catch (error) {
    logVulnerability('critical', `æ‰«ææ‰§è¡Œå‡ºé”™: ${error.message}`);
    console.error(error);
  }

  const duration = Date.now() - startTime;

  // æ‰“å°å®‰å…¨æŠ¥å‘Š
  printSecurityReport(duration);
}

function printSecurityReport(duration) {
  log('\n' + '='.repeat(80), 'magenta');
  log('  ğŸ“Š å®‰å…¨æ‰«ææŠ¥å‘Š', 'bright');
  log('='.repeat(80), 'magenta');

  const passRate = scanResults.total > 0
    ? ((scanResults.passed / scanResults.total) * 100).toFixed(2)
    : 0;

  log(`\n  æ€»æµ‹è¯•æ•°: ${scanResults.total}`, 'cyan');
  log(`  âœ“ é€šè¿‡: ${scanResults.passed}`, 'green');
  log(`  âœ— å¤±è´¥: ${scanResults.failed}`, scanResults.failed > 0 ? 'red' : 'green');
  log(`  å®‰å…¨é€šè¿‡ç‡: ${passRate}%`, passRate >= 90 ? 'green' : passRate >= 70 ? 'yellow' : 'red');
  log(`  æ‰«æè€—æ—¶: ${(duration / 1000).toFixed(2)}s`, 'cyan');

  log('\n  æ¼æ´ä¸¥é‡ç¨‹åº¦åˆ†å¸ƒ:', 'yellow');
  log(`    ğŸ”´ ä¸¥é‡ (Critical): ${scanResults.critical}`, scanResults.critical > 0 ? 'red' : 'green');
  log(`    ğŸŸ  é«˜å± (High): ${scanResults.high}`, scanResults.high > 0 ? 'red' : 'green');
  log(`    ğŸŸ¡ ä¸­å± (Medium): ${scanResults.medium}`, scanResults.medium > 0 ? 'yellow' : 'green');
  log(`    ğŸ”µ ä½å± (Low): ${scanResults.low}`, 'cyan');

  if (scanResults.vulnerabilities.length > 0) {
    log('\n  å‘ç°çš„å®‰å…¨æ¼æ´:', 'red');
    log('  ' + '-'.repeat(78), 'red');

    scanResults.vulnerabilities.forEach((vuln, index) => {
      const severityIcon = {
        critical: 'ğŸ”´',
        high: 'ğŸŸ ',
        medium: 'ğŸŸ¡',
        low: 'ğŸ”µ'
      };

      log(`\n  ${index + 1}. ${severityIcon[vuln.severity]} [${vuln.severity.toUpperCase()}] ${vuln.name}`, 'red');
      log(`     ${vuln.details}`, 'yellow');
    });
    log('  ' + '-'.repeat(78), 'red');
  }

  log('\n' + '='.repeat(80), 'magenta');

  // ç”Ÿäº§ç¯å¢ƒå»ºè®®
  if (scanResults.critical > 0) {
    log('  âŒ å‘ç°ä¸¥é‡å®‰å…¨æ¼æ´ï¼å¿…é¡»ä¿®å¤åæ‰èƒ½æŠ•å…¥ç”Ÿäº§ä½¿ç”¨ï¼', 'red');
  } else if (scanResults.high > 0) {
    log('  âš ï¸  å‘ç°é«˜å±å®‰å…¨æ¼æ´ï¼å¼ºçƒˆå»ºè®®ä¿®å¤åå†æŠ•å…¥ç”Ÿäº§ä½¿ç”¨ï¼', 'yellow');
  } else if (scanResults.medium > 0) {
    log('  âš ï¸  å‘ç°ä¸­å±å®‰å…¨æ¼æ´ï¼Œå»ºè®®ä¿®å¤åå†æŠ•å…¥ç”Ÿäº§ä½¿ç”¨ã€‚', 'yellow');
  } else if (scanResults.failed === 0) {
    log('  âœ… æœªå‘ç°ä¸¥é‡å®‰å…¨æ¼æ´ï¼ç³»ç»Ÿå¯ä»¥æŠ•å…¥ç”Ÿäº§ä½¿ç”¨ã€‚', 'green');
  } else {
    log('  â„¹ï¸  å‘ç°å°‘é‡ä½å±é—®é¢˜ï¼Œå»ºè®®ä¿®å¤ä»¥æé«˜å®‰å…¨æ€§ã€‚', 'cyan');
  }

  log('='.repeat(80) + '\n', 'magenta');

  // é€€å‡ºç 
  const exitCode = scanResults.critical > 0 || scanResults.high > 0 ? 1 : 0;
  process.exit(exitCode);
}

// ==================== æ‰§è¡Œæ‰«æ ====================

if (require.main === module) {
  // éªŒè¯å‚æ•°
  if (!['mock', 'real'].includes(config.paymentMode)) {
    log('é”™è¯¯ï¼šæ— æ•ˆçš„æ”¯ä»˜æ¨¡å¼ã€‚è¯·ä½¿ç”¨ "mock" æˆ– "real"', 'red');
    log('ä½¿ç”¨æ–¹æ³•: node scripts/security-vulnerability-scan.js [mock|real]', 'cyan');
    process.exit(1);
  }

  if (config.paymentMode === 'real') {
    log('\nâš ï¸  è­¦å‘Šï¼šæ‚¨æ­£åœ¨ä½¿ç”¨çœŸå®æ”¯ä»˜æ¨¡å¼è¿›è¡Œå®‰å…¨æµ‹è¯•ï¼', 'yellow');
    log('è¿™å°†äº§ç”ŸçœŸå®çš„æ”¯ä»˜äº¤æ˜“ã€‚ç¡®è®¤ç»§ç»­å—ï¼Ÿ (y/N)', 'yellow');

    process.stdin.once('data', (data) => {
      const input = data.toString().trim().toLowerCase();
      if (input === 'y' || input === 'yes') {
        runSecurityScan();
      } else {
        log('æ‰«æå·²å–æ¶ˆã€‚', 'cyan');
        process.exit(0);
      }
    });
  } else {
    runSecurityScan();
  }
}

module.exports = { runSecurityScan, scanResults };
